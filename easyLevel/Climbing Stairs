You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step


/*
说明与心得
首先通过笔算数学归纳法，得知这个属于菲波那切数列。
这样的话，就通过菲波那切数列直接写出代码即可。
关于空间时间复杂度的考虑，具体看leecode即可。

————————————————————————————————————————————————
为什么这个问题形成了菲波那切数列呢？
表象；
层数   1层 2层 3层 4层 5层 6层...
步数    1   2   3   5   8  13...

分析：首先我们知道只能走一步或者两步，那么对于每次迈步子，都只有两种情况来缩进到终点的距离，所以可知是二分木的问题。
详情看图即可。图中例子的话，必须是5,5才算正好到达。

再回到它为什么形成了斐波那契数列呢？？？
回答：从出发点开始迈步子，即0层开始，每一层都是只有两种迈法，无论你是几层，起始位置都是从第0层开始迈，
     一直延伸到(n,n)结束然后计数查看(n,n)有几个，即有几种走法。(n,n) = (current step, destination)
     而斐波那契的形成，比如你要走到5层，就必然要通过4层，3层，2层，1层，所以n层的走法必然要包括之前层的走法。
     之于为什么形成Fibonacci 即   该层数走法一定 = 上一层走法 + 上上一层走法   那上上上一层没关系了？
     绝对没关系，因为基层是1层和2层，3层是1层走法和2层走法的和。
     4层的话，一定会包含3层的走法，即最后一步就剩一步走完的走法。
             也一定包含2层的走法，因为最后一步可能就剩两步走完。
     图例的话：(5,5)的个数是8种，(4,5)走到第4层的时候迈一步到达共5种 
                               (3,5)走到第3层的时候迈两步到达共3种
                               
     总结：即快爬完的时候，最后一步无非是走一步还是两步，共两种情况。
           走一步的话，最后迈一步，1234........1
           走两步的话，最后迈两步，1234........2
           所以最后无论一步还是两步，走法不用考虑，考虑前两层的走法即可。
     之前担心，上一层走法和上上一层走法会重复
     那是不可能的，因为最后是走一步还是两步已经分开了。
     且层数不一样走法怎么会一样呢？这个是最关键的，总量不一样所以可能重复。总层数一样才有可能方法重复！！
     某一阶段走的步数一样有可能，不要固化思维。
           
延伸：
————————————————————————————————————————————————————
特例： 那么如果步子不仅仅是一阶或者二阶，假设一步至多迈M阶，
    则 A(M)=A(M-1)+A(M-2)+…..+A(1)+A(0)
     A(0)表示之前没迈一步，之后一步迈完M阶
     A(0)=1;A(1)=1,A(2)=2;
     递推得： A(3)=A(2)+A(1)+A(0) =4
             A(4)=A(3)+A(2)+A(1)+A(0) =8
             A(5)=A(4)+A(3)+A(2)+A(1)+A(0) =16
             …
         得A(M)=2^(M-1);

      推广： M阶楼梯，假设一步迈N阶
       当（1《N《M） 即一步至多M阶，同特例 由特列知 A(M)=2^(M-1);
       当（1《N<M）  即一步至多N阶 
       A(M)=A(M-1)+A(M-2)+…..+A(M-N)         
       递归可得A(M)
--------------------- 
作者：Shwan_Ma 
来源：CSDN 
原文：https://blog.csdn.net/shwan_ma/article/details/50649911?utm_source=copy 
版权声明：本文为博主原创文章，转载请附上博文链接！
————————————————————————————————————————————————
普及Fibonacci Number
两个常量a = (1+sqrt(5))/2 ,b = (1-sqrt(5))/2
F(n) = (a^n - b^n)/sqrt(5) 为通项公式，这样F(n)就形成了Fibonacci数列
————————————————————————————————————————————————
自己动手算用数学归纳法也可以，画图也可以，总之它是斐波那契数列。

注意 当直接使用递归调用的时候，即在函数内部调用函数形成递归。
此时会出现time limit exceeded error。
原因：计算的时候有很多重复的节点，即 F10=F9+F8, F9=F8+F7, F8=F7+F6...   F7重复计算了
所以要用有限的变量，来不断记录最后需要的层数即可。所以衍生出下面的代码。
*/
public class Solution {
    public int ClimbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i <= n; i++) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }  
}
